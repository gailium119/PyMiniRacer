{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Minimal, modern embedded V8 for Python.</p> <p></p> <p>Full documentation.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Latest ECMAScript support</li> <li>Web Assembly support</li> <li>Unicode support</li> <li>Thread safe</li> <li>Re-usable contexts</li> </ul> <p>MiniRacer can be easily used by Django or Flask projects to minify assets, run babel or WASM modules.</p>"},{"location":"#new-home-as-of-march-2024","title":"New home! (As of March 2024)","text":"<p>PyMiniRacer was created by Sqreen, and originally lived at https://github.com/sqreen/PyMiniRacer with the PyPI package <code>py-mini-racer</code>.</p> <p>As of March 2024, after a few years without updates, I have reached out to the original Sqreen team. We agreed that I should fork PyMiniRacer, giving it a new home at https://github.com/bpcreech/PyMiniRacer with a new PyPI package <code>mini-racer</code> (note: no <code>py-</code>). It now has a new version for the first time since 2021!</p>"},{"location":"#examples","title":"Examples","text":"<p>MiniRacer is straightforward to use:</p> <pre><code>    $ pip install mini-racer\n</code></pre> <p>and then:</p> <pre><code>    $ python3\n    &gt;&gt;&gt; from py_mini_racer import MiniRacer\n    &gt;&gt;&gt; ctx = MiniRacer()\n    &gt;&gt;&gt; ctx.eval(\"1+1\")\n    2\n    &gt;&gt;&gt; ctx.eval(\"var x = {company: 'Sqreen'}; x.company\")\n    'Sqreen'\n    &gt;&gt;&gt; print(ctx.eval(\"'\u2764'\"))\n    \u2764\n    &gt;&gt;&gt; ctx.eval(\"var fun = () =&gt; ({ foo: 1 });\")\n</code></pre> <p>Variables are kept inside of a context:</p> <pre><code>    &gt;&gt;&gt; ctx.eval(\"x.company\")\n    'Sqreen'\n</code></pre> <p>You can evaluate whole scripts within JavaScript, or define and return JavaScript function objects and call them from Python (new in v0.11.0):</p> <pre><code>    &gt;&gt;&gt; square = ctx.eval(\"a =&gt; a*a\")\n    &gt;&gt;&gt; square(4)\n    16\n</code></pre> <p>JavaScript Objects and Arrays are modeled in Python as dictionaries and lists (or, more precisely, <code>MutableMapping</code> and <code>MutableSequence</code> instances), respectively (new in v0.11.0):</p> <pre><code>    &gt;&gt;&gt; obj = ctx.eval(\"var obj = {'foo': 'bar'}; obj\")\n    &gt;&gt;&gt; obj[\"foo\"]\n    'bar'\n    &gt;&gt;&gt; list(obj.keys())\n    ['foo']\n    &gt;&gt;&gt; arr = ctx.eval(\"var arr = ['a', 'b']; arr\")\n    &gt;&gt;&gt; arr[1]\n    'b'\n    &gt;&gt;&gt; 'a' in arr\n    True\n    &gt;&gt;&gt; arr.append(obj)\n    &gt;&gt;&gt; ctx.eval(\"JSON.stringify(arr)\")\n    '[\"a\",\"b\",{\"foo\":\"bar\"}]'\n</code></pre> <p>Meanwhile, <code>call</code> uses JSON to transfer data between JavaScript and Python, and converts data in bulk:</p> <pre><code>    &gt;&gt;&gt; ctx.call(\"fun\")\n    {'foo': 1}\n</code></pre> <p>Composite values are serialized using JSON. Use a custom JSON encoder when sending non-JSON encodable parameters:</p> <pre><code>    import json\n\n    from datetime import datetime\n\n    class CustomEncoder(json.JSONEncoder):\n\n            def default(self, obj):\n                if isinstance(obj, datetime):\n                    return obj.isoformat()\n\n                return json.JSONEncoder.default(self, obj)\n</code></pre> <pre><code>    &gt;&gt;&gt; ctx.eval(\"var f = function(args) { return args; }\")\n    &gt;&gt;&gt; ctx.call(\"f\", datetime.now(), encoder=CustomEncoder)\n    '2017-03-31T16:51:02.474118'\n</code></pre> <p>MiniRacer is ES6 capable:</p> <pre><code>    &gt;&gt;&gt; ctx.execute(\"[1,2,3].includes(5)\")\n    False\n</code></pre> <p>MiniRacer supports asynchronous execution using JS <code>Promise</code> instances (new in v0.10.0):</p> <pre><code>    &gt;&gt;&gt; promise = ctx.eval(\n    ...     \"new Promise((res, rej) =&gt; setTimeout(() =&gt; res(42), 10000))\")\n    &gt;&gt;&gt; promise.get()  # blocks for 10 seconds, and then:\n    42\n</code></pre> <p>You can use JS <code>Promise</code> instances with Python <code>async</code> (new in v0.10.0):</p> <pre><code>    &gt;&gt;&gt; import asyncio\n    &gt;&gt;&gt; async def demo():\n    ...     promise = ctx.eval(\n    ...         \"new Promise((res, rej) =&gt; setTimeout(() =&gt; res(42), 10000))\")\n    ...     return await promise\n    ... \n    &gt;&gt;&gt; asyncio.run(demo())  # blocks for 10 seconds, and then:\n    42\n</code></pre> <p>JavaScript <code>null</code> and <code>undefined</code> are modeled in Python as <code>None</code> and <code>JSUndefined</code>, respectively:</p> <pre><code>    &gt;&gt;&gt; list(ctx.eval(\"[undefined, null]\"))\n    [JSUndefined, None]\n</code></pre> <p>You can install callbacks from JavaScript to Python (new in v0.12.0):</p> <pre><code>    &gt;&gt;&gt; async def read_file(fn):\n    ...     with open(fn) as f:  # (or aiofiles would be even better here)\n    ...         return f.read()\n    ...\n    &gt;&gt;&gt; async def get_dictionary():\n    ...    async with ctx.wrap_py_function(read_file) as jsfunc:\n    ...        # \"Install\" our JS function on the global \"this\" object:\n    ...        ctx.eval('this')['read_file'] = jsfunc\n    ...        d = await ctx.eval('this.read_file(\"/usr/share/dict/words\")')\n    ...        return d.split()\n    ...\n    &gt;&gt;&gt; dictionary = asyncio.run(get_dictionary())\n    &gt;&gt;&gt; print(dictionary[0:10])\n    ['A', 'AA', 'AAA', \"AA's\", 'AB', 'ABC', \"ABC's\", 'ABCs', 'ABM', \"ABM's\"]\n</code></pre> <p>Note that adding Python callbacks may degrade the security properties of PyMiniRacer! See PyMiniRacer's security goals.</p> <p>MiniRacer supports the ECMA <code>Intl</code> API:</p> <pre><code>    # Indonesian dates!\n    &gt;&gt;&gt; ctx.eval('Intl.DateTimeFormat([\"ban\", \"id\"]).format(new Date())')\n    '16/3/2024'\n</code></pre> <p>V8 heap information can be retrieved:</p> <pre><code>    &gt;&gt;&gt; ctx.heap_stats()\n    {'total_physical_size': 1613896,\n     'used_heap_size': 1512520,\n     'total_heap_size': 3997696,\n     'total_heap_size_executable': 3145728,\n     'heap_size_limit': 1501560832}\n</code></pre> <p>A WASM example is available in the <code>tests</code>.</p>"},{"location":"#compatibility","title":"Compatibility","text":"<p>PyMiniRacer is compatible with Python 3.8-3.12 and is based on <code>ctypes</code>.</p> <p>PyMiniRacer is distributed using wheels on PyPI. The wheels are intended to provide compatibility with:</p> OS x86_64 aarch64 macOS \u2265 10.9 \u2713 \u2713 Windows \u2265 10 \u2713 \u2716 Ubuntu \u2265 20.04 \u2713 \u2713 Debian \u2265 11 \u2713 \u2713 RHEL \u2265 9 \u2713 \u2713 other Linuxes with glibc \u2265 2.31 \u2713 \u2713 Alpine \u2265 3.19 \u2713 \u2713 other Linux with musl \u2265 1.2 \u2713 \u2713 <p>If you have a up-to-date pip and it doesn't use a wheel, you might have an environment for which no wheel is built. Please open an issue.</p>"},{"location":"#developing-and-releasing-pyminiracer","title":"Developing and releasing PyMiniRacer","text":"<p>See the contribution guide.</p>"},{"location":"#credits","title":"Credits","text":"<p>Built with love by Sqreen.</p> <p>PyMiniRacer launch was described in <code>this blog post</code>.</p> <p>PyMiniRacer is inspired by mini_racer, built for the Ruby world by Sam Saffron.</p> <p>In 2024, PyMiniRacer was revived, and adopted by Ben Creech. Upon discussion with the original Sqreen authors, we decided to re-launch PyMiniRacer as a fork under https://github.com/bpcreech/PyMiniRacer and https://pypi.org/project/mini-racer/.</p>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#py_mini_racer.JSArray","title":"<code>JSArray</code>","text":"<p>               Bases: <code>MutableSequence[PythonJSConvertedTypes]</code>, <code>JSObjectImpl</code></p> <p>JavaScript array.</p> <p>Has Pythonic MutableSequence methods (e.g., <code>insert()</code>, <code>__getitem__()</code>, ...).</p> Source code in <code>src/py_mini_racer/_objects.py</code> <pre><code>class JSArray(MutableSequence[PythonJSConvertedTypes], JSObjectImpl):\n    \"\"\"JavaScript array.\n\n    Has Pythonic MutableSequence methods (e.g., `insert()`, `__getitem__()`, ...).\n    \"\"\"\n\n    def __len__(self) -&gt; int:\n        ret = self._ctx.get_object_item(self, \"length\")\n        return cast(int, ret)\n\n    def __getitem__(self, index: int | slice) -&gt; Any:\n        if not isinstance(index, int):\n            raise TypeError\n\n        index = op_index(index)\n        if index &lt; 0:\n            index += len(self)\n\n        if 0 &lt;= index &lt; len(self):\n            return self._ctx.get_object_item(self, index)\n\n        raise IndexError\n\n    def __setitem__(self, index: int | slice, val: Any) -&gt; None:\n        if not isinstance(index, int):\n            raise TypeError\n\n        self._ctx.set_object_item(self, index, val)\n\n    def __delitem__(self, index: int | slice) -&gt; None:\n        if not isinstance(index, int):\n            raise TypeError\n\n        if index &gt;= len(self) or index &lt; -len(self):\n            # JavaScript Array.prototype.splice() just ignores deletion beyond the\n            # end of the array, meaning if you pass a very large value here it would\n            # do nothing. Likewise, it just caps negative values at the length of the\n            # array, meaning if you pass a very negative value here it would just\n            # delete element 0.\n            # For consistency with Python lists, let's tell the caller they're out of\n            # bounds:\n            raise JSArrayIndexError\n\n        return self._ctx.del_from_array(self, index)\n\n    def insert(self, index: int, new_obj: PythonJSConvertedTypes) -&gt; None:\n        return self._ctx.array_insert(self, index, new_obj)\n\n    def __iter__(self) -&gt; Iterator[PythonJSConvertedTypes]:\n        for i in range(len(self)):\n            yield self[i]\n</code></pre>"},{"location":"api/#py_mini_racer.JSArrayIndexError","title":"<code>JSArrayIndexError</code>","text":"<p>               Bases: <code>IndexError</code>, <code>MiniRacerBaseException</code></p> <p>Invalid index into a JSArray.</p> Source code in <code>src/py_mini_racer/_objects.py</code> <pre><code>class JSArrayIndexError(IndexError, MiniRacerBaseException):\n    \"\"\"Invalid index into a JSArray.\"\"\"\n\n    def __init__(self) -&gt; None:\n        super().__init__(\"JSArray deletion out of range\")\n</code></pre>"},{"location":"api/#py_mini_racer.JSEvalException","title":"<code>JSEvalException</code>","text":"<p>               Bases: <code>MiniRacerBaseException</code></p> <p>JavaScript could not be executed.</p> Source code in <code>src/py_mini_racer/_types.py</code> <pre><code>class JSEvalException(MiniRacerBaseException):\n    \"\"\"JavaScript could not be executed.\"\"\"\n</code></pre>"},{"location":"api/#py_mini_racer.JSFunction","title":"<code>JSFunction</code>","text":"<p>               Bases: <code>JSMappedObject</code></p> <p>JavaScript function.</p> <p>You can call this object from Python, passing in positional args to match what the JavaScript function expects, along with a keyword argument, <code>timeout_sec</code>.</p> Source code in <code>src/py_mini_racer/_objects.py</code> <pre><code>class JSFunction(JSMappedObject):\n    \"\"\"JavaScript function.\n\n    You can call this object from Python, passing in positional args to match what the\n    JavaScript function expects, along with a keyword argument, `timeout_sec`.\n    \"\"\"\n\n    def __call__(\n        self,\n        *args: PythonJSConvertedTypes,\n        this: JSObjectImpl | JSUndefinedType = JSUndefined,\n        timeout_sec: Numeric | None = None,\n    ) -&gt; PythonJSConvertedTypes:\n        return self._ctx.call_function(self, *args, this=this, timeout_sec=timeout_sec)\n</code></pre>"},{"location":"api/#py_mini_racer.JSKeyError","title":"<code>JSKeyError</code>","text":"<p>               Bases: <code>JSEvalException</code>, <code>KeyError</code></p> <p>No such key found.</p> Source code in <code>src/py_mini_racer/_value_handle.py</code> <pre><code>class JSKeyError(JSEvalException, KeyError):\n    \"\"\"No such key found.\"\"\"\n</code></pre>"},{"location":"api/#py_mini_racer.JSOOMException","title":"<code>JSOOMException</code>","text":"<p>               Bases: <code>JSEvalException</code></p> <p>JavaScript execution ran out of memory.</p> Source code in <code>src/py_mini_racer/_value_handle.py</code> <pre><code>class JSOOMException(JSEvalException):\n    \"\"\"JavaScript execution ran out of memory.\"\"\"\n</code></pre>"},{"location":"api/#py_mini_racer.JSParseException","title":"<code>JSParseException</code>","text":"<p>               Bases: <code>JSEvalException</code></p> <p>JavaScript could not be parsed.</p> Source code in <code>src/py_mini_racer/_value_handle.py</code> <pre><code>class JSParseException(JSEvalException):\n    \"\"\"JavaScript could not be parsed.\"\"\"\n</code></pre>"},{"location":"api/#py_mini_racer.JSPromise","title":"<code>JSPromise</code>","text":"<p>               Bases: <code>JSObjectImpl</code></p> <p>JavaScript Promise.</p> <p>To get a value, call <code>promise.get()</code> to block, or <code>await promise</code> from within an <code>async</code> coroutine. Either will raise a Python exception if the JavaScript Promise is rejected.</p> Source code in <code>src/py_mini_racer/_objects.py</code> <pre><code>class JSPromise(JSObjectImpl):\n    \"\"\"JavaScript Promise.\n\n    To get a value, call `promise.get()` to block, or `await promise` from within an\n    `async` coroutine. Either will raise a Python exception if the JavaScript Promise\n    is rejected.\n    \"\"\"\n\n    def get(self, *, timeout: Numeric | None = None) -&gt; PythonJSConvertedTypes:\n        \"\"\"Get the value, or raise an exception. This call blocks.\n\n        Args:\n            timeout: number of milliseconds after which the execution is interrupted.\n                This is deprecated; use timeout_sec instead.\n        \"\"\"\n\n        future = SyncFuture()\n\n        def future_caller(value: Any) -&gt; None:\n            future.set_result(value)\n\n        self._attach_callbacks_to_promise(future_caller)\n\n        results = future.get(timeout=timeout)\n        return self._unpack_promise_results(results)\n\n    def __await__(self) -&gt; Generator[Any, None, Any]:\n        return self._do_await().__await__()\n\n    async def _do_await(self) -&gt; PythonJSConvertedTypes:\n        loop = get_running_loop()\n        future: Future[PythonJSConvertedTypes] = loop.create_future()\n\n        def future_caller(value: Any) -&gt; None:\n            loop.call_soon_threadsafe(future.set_result, value)\n\n        self._attach_callbacks_to_promise(future_caller)\n\n        results = await future\n        return self._unpack_promise_results(results)\n\n    def _attach_callbacks_to_promise(\n        self,\n        future_caller: Callable[[Any], None],\n    ) -&gt; None:\n        \"\"\"Attach the given Python callbacks to a JS Promise.\"\"\"\n\n        exit_stack = ExitStack()\n\n        def on_resolved_and_cleanup(\n            value: PythonJSConvertedTypes | JSEvalException,\n        ) -&gt; None:\n            exit_stack.__exit__(None, None, None)\n            future_caller([False, cast(JSArray, value)])\n\n        on_resolved_js_func = exit_stack.enter_context(\n            self._ctx.js_callback(on_resolved_and_cleanup)\n        )\n\n        def on_rejected_and_cleanup(\n            value: PythonJSConvertedTypes | JSEvalException,\n        ) -&gt; None:\n            exit_stack.__exit__(None, None, None)\n            future_caller([True, cast(JSArray, value)])\n\n        on_rejected_js_func = exit_stack.enter_context(\n            self._ctx.js_callback(on_rejected_and_cleanup)\n        )\n\n        self._ctx.promise_then(self, on_resolved_js_func, on_rejected_js_func)\n\n    def _unpack_promise_results(self, results: Any) -&gt; PythonJSConvertedTypes:\n        is_rejected, argv = results\n        result = cast(PythonJSConvertedTypes, cast(JSArray, argv)[0])\n        if is_rejected:\n            raise JSPromiseError(result)\n        return result\n</code></pre>"},{"location":"api/#py_mini_racer.JSPromise.get","title":"<code>get(*, timeout=None)</code>","text":"<p>Get the value, or raise an exception. This call blocks.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>Numeric | None</code> <p>number of milliseconds after which the execution is interrupted. This is deprecated; use timeout_sec instead.</p> <code>None</code> Source code in <code>src/py_mini_racer/_objects.py</code> <pre><code>def get(self, *, timeout: Numeric | None = None) -&gt; PythonJSConvertedTypes:\n    \"\"\"Get the value, or raise an exception. This call blocks.\n\n    Args:\n        timeout: number of milliseconds after which the execution is interrupted.\n            This is deprecated; use timeout_sec instead.\n    \"\"\"\n\n    future = SyncFuture()\n\n    def future_caller(value: Any) -&gt; None:\n        future.set_result(value)\n\n    self._attach_callbacks_to_promise(future_caller)\n\n    results = future.get(timeout=timeout)\n    return self._unpack_promise_results(results)\n</code></pre>"},{"location":"api/#py_mini_racer.JSPromiseError","title":"<code>JSPromiseError</code>","text":"<p>               Bases: <code>MiniRacerBaseException</code></p> <p>JavaScript rejected a promise.</p> Source code in <code>src/py_mini_racer/_objects.py</code> <pre><code>class JSPromiseError(MiniRacerBaseException):\n    \"\"\"JavaScript rejected a promise.\"\"\"\n\n    def __init__(self, reason: PythonJSConvertedTypes) -&gt; None:\n        super().__init__(\n            f\"JavaScript rejected promise with reason: {_get_exception_msg(reason)}\\n\"\n        )\n        self.reason = reason\n</code></pre>"},{"location":"api/#py_mini_racer.JSSymbol","title":"<code>JSSymbol</code>","text":"<p>               Bases: <code>JSMappedObject</code></p> <p>JavaScript symbol.</p> Source code in <code>src/py_mini_racer/_objects.py</code> <pre><code>class JSSymbol(JSMappedObject):\n    \"\"\"JavaScript symbol.\"\"\"\n</code></pre>"},{"location":"api/#py_mini_racer.JSTimeoutException","title":"<code>JSTimeoutException</code>","text":"<p>               Bases: <code>JSEvalException</code></p> <p>JavaScript execution timed out.</p> Source code in <code>src/py_mini_racer/_types.py</code> <pre><code>class JSTimeoutException(JSEvalException):\n    \"\"\"JavaScript execution timed out.\"\"\"\n\n    def __init__(self) -&gt; None:\n        super().__init__(\"JavaScript was terminated by timeout\")\n</code></pre>"},{"location":"api/#py_mini_racer.JSUndefinedType","title":"<code>JSUndefinedType</code>","text":"<p>The JavaScript undefined type.</p> <p>Where JavaScript null is represented as None, undefined is represented as this type.</p> Source code in <code>src/py_mini_racer/_types.py</code> <pre><code>class JSUndefinedType:\n    \"\"\"The JavaScript undefined type.\n\n    Where JavaScript null is represented as None, undefined is represented as this\n    type.\"\"\"\n\n    def __bool__(self) -&gt; bool:\n        return False\n\n    def __repr__(self) -&gt; str:\n        return \"JSUndefined\"\n</code></pre>"},{"location":"api/#py_mini_racer.JSValueError","title":"<code>JSValueError</code>","text":"<p>               Bases: <code>JSEvalException</code>, <code>ValueError</code></p> <p>Bad value passed to JavaScript engine.</p> Source code in <code>src/py_mini_racer/_value_handle.py</code> <pre><code>class JSValueError(JSEvalException, ValueError):\n    \"\"\"Bad value passed to JavaScript engine.\"\"\"\n</code></pre>"},{"location":"api/#py_mini_racer.LibAlreadyInitializedError","title":"<code>LibAlreadyInitializedError</code>","text":"<p>               Bases: <code>MiniRacerBaseException</code></p> <p>MiniRacer-wrapped V8 build not found.</p> Source code in <code>src/py_mini_racer/_dll.py</code> <pre><code>class LibAlreadyInitializedError(MiniRacerBaseException):\n    \"\"\"MiniRacer-wrapped V8 build not found.\"\"\"\n\n    def __init__(self) -&gt; None:\n        super().__init__(\n            \"MiniRacer was already initialized before the call to init_mini_racer\"\n        )\n</code></pre>"},{"location":"api/#py_mini_racer.LibNotFoundError","title":"<code>LibNotFoundError</code>","text":"<p>               Bases: <code>MiniRacerBaseException</code></p> <p>MiniRacer-wrapped V8 build not found.</p> Source code in <code>src/py_mini_racer/_dll.py</code> <pre><code>class LibNotFoundError(MiniRacerBaseException):\n    \"\"\"MiniRacer-wrapped V8 build not found.\"\"\"\n\n    def __init__(self, path: str):\n        super().__init__(f\"Native library or dependency not available at {path}\")\n</code></pre>"},{"location":"api/#py_mini_racer.MiniRacer","title":"<code>MiniRacer</code>","text":"<p>MiniRacer evaluates JavaScript code using a V8 isolate.</p> <p>A MiniRacer instance can be explicitly closed using the close() method, or by using the MiniRacer as a context manager, i.e,:</p> <p>with MiniRacer() as mr:     ...</p> <p>The MiniRacer instance will otherwise clean up the underlying V8 resource upon garbage collection.</p> <p>Attributes:</p> Name Type Description <code>json_impl</code> <code>Any</code> <p>JSON module used by helper methods default is json</p> Source code in <code>src/py_mini_racer/_mini_racer.py</code> <pre><code>class MiniRacer:\n    \"\"\"\n    MiniRacer evaluates JavaScript code using a V8 isolate.\n\n    A MiniRacer instance can be explicitly closed using the close() method, or by using\n    the MiniRacer as a context manager, i.e,:\n\n    with MiniRacer() as mr:\n        ...\n\n    The MiniRacer instance will otherwise clean up the underlying V8 resource upon\n    garbage collection.\n\n    Attributes:\n        json_impl: JSON module used by helper methods default is\n            [json](https://docs.python.org/3/library/json.html)\n    \"\"\"\n\n    json_impl: ClassVar[Any] = json\n\n    def __init__(self) -&gt; None:\n        dll = init_mini_racer(ignore_duplicate_init=True)\n\n        self._ctx = Context(dll)\n\n        self.eval(INSTALL_SET_TIMEOUT)\n\n    def close(self) -&gt; None:\n        \"\"\"Close this MiniRacer instance.\n\n        It is an error to use this MiniRacer instance or any JS objects returned by it\n        after calling this method.\n        \"\"\"\n        self._ctx.close()\n\n    def __enter__(self) -&gt; Self:\n        return self\n\n    def __exit__(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_val: BaseException | None,\n        exc_tb: TracebackType | None,\n    ) -&gt; None:\n        del exc_type\n        del exc_val\n        del exc_tb\n        self.close()\n\n    @property\n    def v8_version(self) -&gt; str:\n        \"\"\"Return the V8 version string.\"\"\"\n        return self._ctx.v8_version()\n\n    def eval(\n        self,\n        code: str,\n        timeout: Numeric | None = None,\n        timeout_sec: Numeric | None = None,\n        max_memory: int | None = None,\n    ) -&gt; PythonJSConvertedTypes:\n        \"\"\"Evaluate JavaScript code in the V8 isolate.\n\n        Side effects from the JavaScript evaluation is persisted inside a context\n        (meaning variables set are kept for the next evaluation).\n\n        The JavaScript value returned by the last expression in `code` is converted to\n        a Python value and returned by this method. Only primitive types are supported\n        (numbers, strings, buffers...). Use the\n        [py_mini_racer.MiniRacer.execute][] method to return more complex\n        types such as arrays or objects.\n\n        The evaluation can be interrupted by an exception for several reasons: a limit\n        was reached, the code could not be parsed, a returned value could not be\n        converted to a Python value.\n\n        Args:\n            code: JavaScript code\n            timeout: number of milliseconds after which the execution is interrupted.\n                This is deprecated; use timeout_sec instead.\n            timeout_sec: number of seconds after which the execution is interrupted\n            max_memory: hard memory limit, in bytes, after which the execution is\n                interrupted.\n        \"\"\"\n\n        if max_memory is not None:\n            self.set_hard_memory_limit(max_memory)\n\n        if timeout:\n            # PyMiniRacer unfortunately uses milliseconds while Python and\n            # Syst\u00e8me international d'unit\u00e9s use seconds.\n            timeout_sec = timeout / 1000\n\n        return self._ctx.evaluate(code=code, timeout_sec=timeout_sec)\n\n    def execute(\n        self,\n        expr: str,\n        timeout: Numeric | None = None,\n        timeout_sec: Numeric | None = None,\n        max_memory: int | None = None,\n    ) -&gt; Any:\n        \"\"\"Helper to evaluate a JavaScript expression and return composite types.\n\n        Returned value is serialized to JSON inside the V8 isolate and deserialized\n        using `json_impl`.\n\n        Args:\n            expr: JavaScript expression\n            timeout: number of milliseconds after which the execution is interrupted.\n                This is deprecated; use timeout_sec instead.\n            timeout_sec: number of seconds after which the execution is interrupted\n            max_memory: hard memory limit, in bytes, after which the execution is\n                interrupted.\n        \"\"\"\n\n        if timeout:\n            # PyMiniRacer unfortunately uses milliseconds while Python and\n            # Syst\u00e8me international d'unit\u00e9s use seconds.\n            timeout_sec = timeout / 1000\n\n        wrapped_expr = f\"JSON.stringify((function(){{return ({expr})}})())\"\n        ret = self.eval(wrapped_expr, timeout_sec=timeout_sec, max_memory=max_memory)\n        if not isinstance(ret, str):\n            raise WrongReturnTypeException(type(ret))\n        return self.json_impl.loads(ret)\n\n    def call(\n        self,\n        expr: str,\n        *args: Any,\n        encoder: JSONEncoder | None = None,\n        timeout: Numeric | None = None,\n        timeout_sec: Numeric | None = None,\n        max_memory: int | None = None,\n    ) -&gt; Any:\n        \"\"\"Helper to call a JavaScript function and return compositve types.\n\n        The `expr` argument refers to a JavaScript function in the current V8\n        isolate context. Further positional arguments are serialized using the JSON\n        implementation `json_impl` and passed to the JavaScript function as arguments.\n\n        Returned value is serialized to JSON inside the V8 isolate and deserialized\n        using `json_impl`.\n\n        Args:\n            expr: JavaScript expression referring to a function\n            encoder: Custom JSON encoder\n            timeout: number of milliseconds after which the execution is\n                interrupted.\n            timeout_sec: number of seconds after which the execution is interrupted\n            max_memory: hard memory limit, in bytes, after which the execution is\n                interrupted\n        \"\"\"\n\n        if timeout:\n            # PyMiniRacer unfortunately uses milliseconds while Python and\n            # Syst\u00e8me international d'unit\u00e9s use seconds.\n            timeout_sec = timeout / 1000\n\n        json_args = self.json_impl.dumps(args, separators=(\",\", \":\"), cls=encoder)\n        js = f\"{expr}.apply(this, {json_args})\"\n        return self.execute(js, timeout_sec=timeout_sec, max_memory=max_memory)\n\n    def wrap_py_function(\n        self,\n        func: PyJsFunctionType,\n    ) -&gt; AbstractAsyncContextManager[JSFunction]:\n        \"\"\"Wrap a Python function such that it can be called from JS.\n\n        To be wrapped and exposed in JavaScript, a Python function should:\n\n          1. Be async,\n          2. Accept variable positional arguments each of type PythonJSConvertedTypes,\n             and\n          3. Return one value of type PythonJSConvertedTypes (a type union which\n             includes None).\n\n        The function is rendered on the JavaScript side as an async function (i.e., a\n        function which returns a Promise).\n\n        Returns:\n            An async context manager which, when entered, yields a JS Function which\n            can be passed into MiniRacer and called by JS code.\n        \"\"\"\n\n        return self._ctx.wrap_py_function(func)\n\n    def set_hard_memory_limit(self, limit: int) -&gt; None:\n        \"\"\"Set a hard memory limit on this V8 isolate.\n\n        JavaScript execution will be terminated when this limit is reached.\n\n        :param int limit: memory limit in bytes or 0 to reset the limit\n        \"\"\"\n        self._ctx.set_hard_memory_limit(limit)\n\n    def set_soft_memory_limit(self, limit: int) -&gt; None:\n        \"\"\"Set a soft memory limit on this V8 isolate.\n\n        The Garbage Collection will use a more aggressive strategy when\n        the soft limit is reached but the execution will not be stopped.\n\n        :param int limit: memory limit in bytes or 0 to reset the limit\n        \"\"\"\n        self._ctx.set_soft_memory_limit(limit)\n\n    def was_hard_memory_limit_reached(self) -&gt; bool:\n        \"\"\"Return true if the hard memory limit was reached on the V8 isolate.\"\"\"\n        return self._ctx.was_hard_memory_limit_reached()\n\n    def was_soft_memory_limit_reached(self) -&gt; bool:\n        \"\"\"Return true if the soft memory limit was reached on the V8 isolate.\"\"\"\n        return self._ctx.was_soft_memory_limit_reached()\n\n    def low_memory_notification(self) -&gt; None:\n        \"\"\"Ask the V8 isolate to collect memory more aggressively.\"\"\"\n        self._ctx.low_memory_notification()\n\n    def heap_stats(self) -&gt; Any:\n        \"\"\"Return the V8 isolate heap statistics.\"\"\"\n\n        return self.json_impl.loads(self._ctx.heap_stats())\n</code></pre>"},{"location":"api/#py_mini_racer.MiniRacer.v8_version","title":"<code>v8_version</code>  <code>property</code>","text":"<p>Return the V8 version string.</p>"},{"location":"api/#py_mini_racer.MiniRacer.call","title":"<code>call(expr, *args, encoder=None, timeout=None, timeout_sec=None, max_memory=None)</code>","text":"<p>Helper to call a JavaScript function and return compositve types.</p> <p>The <code>expr</code> argument refers to a JavaScript function in the current V8 isolate context. Further positional arguments are serialized using the JSON implementation <code>json_impl</code> and passed to the JavaScript function as arguments.</p> <p>Returned value is serialized to JSON inside the V8 isolate and deserialized using <code>json_impl</code>.</p> <p>Parameters:</p> Name Type Description Default <code>expr</code> <code>str</code> <p>JavaScript expression referring to a function</p> required <code>encoder</code> <code>JSONEncoder | None</code> <p>Custom JSON encoder</p> <code>None</code> <code>timeout</code> <code>Numeric | None</code> <p>number of milliseconds after which the execution is interrupted.</p> <code>None</code> <code>timeout_sec</code> <code>Numeric | None</code> <p>number of seconds after which the execution is interrupted</p> <code>None</code> <code>max_memory</code> <code>int | None</code> <p>hard memory limit, in bytes, after which the execution is interrupted</p> <code>None</code> Source code in <code>src/py_mini_racer/_mini_racer.py</code> <pre><code>def call(\n    self,\n    expr: str,\n    *args: Any,\n    encoder: JSONEncoder | None = None,\n    timeout: Numeric | None = None,\n    timeout_sec: Numeric | None = None,\n    max_memory: int | None = None,\n) -&gt; Any:\n    \"\"\"Helper to call a JavaScript function and return compositve types.\n\n    The `expr` argument refers to a JavaScript function in the current V8\n    isolate context. Further positional arguments are serialized using the JSON\n    implementation `json_impl` and passed to the JavaScript function as arguments.\n\n    Returned value is serialized to JSON inside the V8 isolate and deserialized\n    using `json_impl`.\n\n    Args:\n        expr: JavaScript expression referring to a function\n        encoder: Custom JSON encoder\n        timeout: number of milliseconds after which the execution is\n            interrupted.\n        timeout_sec: number of seconds after which the execution is interrupted\n        max_memory: hard memory limit, in bytes, after which the execution is\n            interrupted\n    \"\"\"\n\n    if timeout:\n        # PyMiniRacer unfortunately uses milliseconds while Python and\n        # Syst\u00e8me international d'unit\u00e9s use seconds.\n        timeout_sec = timeout / 1000\n\n    json_args = self.json_impl.dumps(args, separators=(\",\", \":\"), cls=encoder)\n    js = f\"{expr}.apply(this, {json_args})\"\n    return self.execute(js, timeout_sec=timeout_sec, max_memory=max_memory)\n</code></pre>"},{"location":"api/#py_mini_racer.MiniRacer.close","title":"<code>close()</code>","text":"<p>Close this MiniRacer instance.</p> <p>It is an error to use this MiniRacer instance or any JS objects returned by it after calling this method.</p> Source code in <code>src/py_mini_racer/_mini_racer.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Close this MiniRacer instance.\n\n    It is an error to use this MiniRacer instance or any JS objects returned by it\n    after calling this method.\n    \"\"\"\n    self._ctx.close()\n</code></pre>"},{"location":"api/#py_mini_racer.MiniRacer.eval","title":"<code>eval(code, timeout=None, timeout_sec=None, max_memory=None)</code>","text":"<p>Evaluate JavaScript code in the V8 isolate.</p> <p>Side effects from the JavaScript evaluation is persisted inside a context (meaning variables set are kept for the next evaluation).</p> <p>The JavaScript value returned by the last expression in <code>code</code> is converted to a Python value and returned by this method. Only primitive types are supported (numbers, strings, buffers...). Use the py_mini_racer.MiniRacer.execute method to return more complex types such as arrays or objects.</p> <p>The evaluation can be interrupted by an exception for several reasons: a limit was reached, the code could not be parsed, a returned value could not be converted to a Python value.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>JavaScript code</p> required <code>timeout</code> <code>Numeric | None</code> <p>number of milliseconds after which the execution is interrupted. This is deprecated; use timeout_sec instead.</p> <code>None</code> <code>timeout_sec</code> <code>Numeric | None</code> <p>number of seconds after which the execution is interrupted</p> <code>None</code> <code>max_memory</code> <code>int | None</code> <p>hard memory limit, in bytes, after which the execution is interrupted.</p> <code>None</code> Source code in <code>src/py_mini_racer/_mini_racer.py</code> <pre><code>def eval(\n    self,\n    code: str,\n    timeout: Numeric | None = None,\n    timeout_sec: Numeric | None = None,\n    max_memory: int | None = None,\n) -&gt; PythonJSConvertedTypes:\n    \"\"\"Evaluate JavaScript code in the V8 isolate.\n\n    Side effects from the JavaScript evaluation is persisted inside a context\n    (meaning variables set are kept for the next evaluation).\n\n    The JavaScript value returned by the last expression in `code` is converted to\n    a Python value and returned by this method. Only primitive types are supported\n    (numbers, strings, buffers...). Use the\n    [py_mini_racer.MiniRacer.execute][] method to return more complex\n    types such as arrays or objects.\n\n    The evaluation can be interrupted by an exception for several reasons: a limit\n    was reached, the code could not be parsed, a returned value could not be\n    converted to a Python value.\n\n    Args:\n        code: JavaScript code\n        timeout: number of milliseconds after which the execution is interrupted.\n            This is deprecated; use timeout_sec instead.\n        timeout_sec: number of seconds after which the execution is interrupted\n        max_memory: hard memory limit, in bytes, after which the execution is\n            interrupted.\n    \"\"\"\n\n    if max_memory is not None:\n        self.set_hard_memory_limit(max_memory)\n\n    if timeout:\n        # PyMiniRacer unfortunately uses milliseconds while Python and\n        # Syst\u00e8me international d'unit\u00e9s use seconds.\n        timeout_sec = timeout / 1000\n\n    return self._ctx.evaluate(code=code, timeout_sec=timeout_sec)\n</code></pre>"},{"location":"api/#py_mini_racer.MiniRacer.execute","title":"<code>execute(expr, timeout=None, timeout_sec=None, max_memory=None)</code>","text":"<p>Helper to evaluate a JavaScript expression and return composite types.</p> <p>Returned value is serialized to JSON inside the V8 isolate and deserialized using <code>json_impl</code>.</p> <p>Parameters:</p> Name Type Description Default <code>expr</code> <code>str</code> <p>JavaScript expression</p> required <code>timeout</code> <code>Numeric | None</code> <p>number of milliseconds after which the execution is interrupted. This is deprecated; use timeout_sec instead.</p> <code>None</code> <code>timeout_sec</code> <code>Numeric | None</code> <p>number of seconds after which the execution is interrupted</p> <code>None</code> <code>max_memory</code> <code>int | None</code> <p>hard memory limit, in bytes, after which the execution is interrupted.</p> <code>None</code> Source code in <code>src/py_mini_racer/_mini_racer.py</code> <pre><code>def execute(\n    self,\n    expr: str,\n    timeout: Numeric | None = None,\n    timeout_sec: Numeric | None = None,\n    max_memory: int | None = None,\n) -&gt; Any:\n    \"\"\"Helper to evaluate a JavaScript expression and return composite types.\n\n    Returned value is serialized to JSON inside the V8 isolate and deserialized\n    using `json_impl`.\n\n    Args:\n        expr: JavaScript expression\n        timeout: number of milliseconds after which the execution is interrupted.\n            This is deprecated; use timeout_sec instead.\n        timeout_sec: number of seconds after which the execution is interrupted\n        max_memory: hard memory limit, in bytes, after which the execution is\n            interrupted.\n    \"\"\"\n\n    if timeout:\n        # PyMiniRacer unfortunately uses milliseconds while Python and\n        # Syst\u00e8me international d'unit\u00e9s use seconds.\n        timeout_sec = timeout / 1000\n\n    wrapped_expr = f\"JSON.stringify((function(){{return ({expr})}})())\"\n    ret = self.eval(wrapped_expr, timeout_sec=timeout_sec, max_memory=max_memory)\n    if not isinstance(ret, str):\n        raise WrongReturnTypeException(type(ret))\n    return self.json_impl.loads(ret)\n</code></pre>"},{"location":"api/#py_mini_racer.MiniRacer.heap_stats","title":"<code>heap_stats()</code>","text":"<p>Return the V8 isolate heap statistics.</p> Source code in <code>src/py_mini_racer/_mini_racer.py</code> <pre><code>def heap_stats(self) -&gt; Any:\n    \"\"\"Return the V8 isolate heap statistics.\"\"\"\n\n    return self.json_impl.loads(self._ctx.heap_stats())\n</code></pre>"},{"location":"api/#py_mini_racer.MiniRacer.low_memory_notification","title":"<code>low_memory_notification()</code>","text":"<p>Ask the V8 isolate to collect memory more aggressively.</p> Source code in <code>src/py_mini_racer/_mini_racer.py</code> <pre><code>def low_memory_notification(self) -&gt; None:\n    \"\"\"Ask the V8 isolate to collect memory more aggressively.\"\"\"\n    self._ctx.low_memory_notification()\n</code></pre>"},{"location":"api/#py_mini_racer.MiniRacer.set_hard_memory_limit","title":"<code>set_hard_memory_limit(limit)</code>","text":"<p>Set a hard memory limit on this V8 isolate.</p> <p>JavaScript execution will be terminated when this limit is reached.</p> <p>:param int limit: memory limit in bytes or 0 to reset the limit</p> Source code in <code>src/py_mini_racer/_mini_racer.py</code> <pre><code>def set_hard_memory_limit(self, limit: int) -&gt; None:\n    \"\"\"Set a hard memory limit on this V8 isolate.\n\n    JavaScript execution will be terminated when this limit is reached.\n\n    :param int limit: memory limit in bytes or 0 to reset the limit\n    \"\"\"\n    self._ctx.set_hard_memory_limit(limit)\n</code></pre>"},{"location":"api/#py_mini_racer.MiniRacer.set_soft_memory_limit","title":"<code>set_soft_memory_limit(limit)</code>","text":"<p>Set a soft memory limit on this V8 isolate.</p> <p>The Garbage Collection will use a more aggressive strategy when the soft limit is reached but the execution will not be stopped.</p> <p>:param int limit: memory limit in bytes or 0 to reset the limit</p> Source code in <code>src/py_mini_racer/_mini_racer.py</code> <pre><code>def set_soft_memory_limit(self, limit: int) -&gt; None:\n    \"\"\"Set a soft memory limit on this V8 isolate.\n\n    The Garbage Collection will use a more aggressive strategy when\n    the soft limit is reached but the execution will not be stopped.\n\n    :param int limit: memory limit in bytes or 0 to reset the limit\n    \"\"\"\n    self._ctx.set_soft_memory_limit(limit)\n</code></pre>"},{"location":"api/#py_mini_racer.MiniRacer.was_hard_memory_limit_reached","title":"<code>was_hard_memory_limit_reached()</code>","text":"<p>Return true if the hard memory limit was reached on the V8 isolate.</p> Source code in <code>src/py_mini_racer/_mini_racer.py</code> <pre><code>def was_hard_memory_limit_reached(self) -&gt; bool:\n    \"\"\"Return true if the hard memory limit was reached on the V8 isolate.\"\"\"\n    return self._ctx.was_hard_memory_limit_reached()\n</code></pre>"},{"location":"api/#py_mini_racer.MiniRacer.was_soft_memory_limit_reached","title":"<code>was_soft_memory_limit_reached()</code>","text":"<p>Return true if the soft memory limit was reached on the V8 isolate.</p> Source code in <code>src/py_mini_racer/_mini_racer.py</code> <pre><code>def was_soft_memory_limit_reached(self) -&gt; bool:\n    \"\"\"Return true if the soft memory limit was reached on the V8 isolate.\"\"\"\n    return self._ctx.was_soft_memory_limit_reached()\n</code></pre>"},{"location":"api/#py_mini_racer.MiniRacer.wrap_py_function","title":"<code>wrap_py_function(func)</code>","text":"<p>Wrap a Python function such that it can be called from JS.</p> <p>To be wrapped and exposed in JavaScript, a Python function should:</p> <ol> <li>Be async,</li> <li>Accept variable positional arguments each of type PythonJSConvertedTypes,      and</li> <li>Return one value of type PythonJSConvertedTypes (a type union which      includes None).</li> </ol> <p>The function is rendered on the JavaScript side as an async function (i.e., a function which returns a Promise).</p> <p>Returns:</p> Type Description <code>AbstractAsyncContextManager[JSFunction]</code> <p>An async context manager which, when entered, yields a JS Function which</p> <code>AbstractAsyncContextManager[JSFunction]</code> <p>can be passed into MiniRacer and called by JS code.</p> Source code in <code>src/py_mini_racer/_mini_racer.py</code> <pre><code>def wrap_py_function(\n    self,\n    func: PyJsFunctionType,\n) -&gt; AbstractAsyncContextManager[JSFunction]:\n    \"\"\"Wrap a Python function such that it can be called from JS.\n\n    To be wrapped and exposed in JavaScript, a Python function should:\n\n      1. Be async,\n      2. Accept variable positional arguments each of type PythonJSConvertedTypes,\n         and\n      3. Return one value of type PythonJSConvertedTypes (a type union which\n         includes None).\n\n    The function is rendered on the JavaScript side as an async function (i.e., a\n    function which returns a Promise).\n\n    Returns:\n        An async context manager which, when entered, yields a JS Function which\n        can be passed into MiniRacer and called by JS code.\n    \"\"\"\n\n    return self._ctx.wrap_py_function(func)\n</code></pre>"},{"location":"api/#py_mini_racer.init_mini_racer","title":"<code>init_mini_racer(*, flags=DEFAULT_V8_FLAGS, ignore_duplicate_init=False)</code>","text":"<p>Initialize py_mini_racer (and V8).</p> <p>This function can optionally be used to set V8 flags. This function can be called at most once, before any instances of MiniRacer are initialized. Instances of MiniRacer will automatically call this function to initialize MiniRacer and V8.</p> Source code in <code>src/py_mini_racer/_dll.py</code> <pre><code>def init_mini_racer(\n    *, flags: Iterable[str] = DEFAULT_V8_FLAGS, ignore_duplicate_init: bool = False\n) -&gt; ctypes.CDLL:\n    \"\"\"Initialize py_mini_racer (and V8).\n\n    This function can optionally be used to set V8 flags. This function can be called\n    at most once, before any instances of MiniRacer are initialized. Instances of\n    MiniRacer will automatically call this function to initialize MiniRacer and V8.\n    \"\"\"\n\n    global _dll_handle_context_manager  # noqa: PLW0603\n    global _dll_handle  # noqa: PLW0603\n\n    with _init_lock:\n        if _dll_handle is None:\n            _dll_handle_context_manager = _open_dll(flags)\n            _dll_handle = _dll_handle_context_manager.__enter__()\n            # Note: we never call _dll_handle_context_manager.__exit__() because it's\n            # designed as a singleton. But we could if we wanted to!\n        elif not ignore_duplicate_init:\n            raise LibAlreadyInitializedError\n\n        return _dll_handle\n</code></pre>"},{"location":"architecture/","title":"Architecture","text":"<p>This document contains some notes about the design of PyMiniRacer.</p>"},{"location":"architecture/#security-goals","title":"Security goals","text":"<p>First and foremost, PyMiniRacer makes no guarantees or warrantees, as noted in the license. This section documents the security goals of PyMiniRacer. Anything that doesn't meet these goals should be considered to be a bug (but with no warrantee or even a guaranteed path to remediation).</p>"},{"location":"architecture/#pyminiracer-should-be-able-to-run-untrusted-javascript-code","title":"PyMiniRacer should be able to run untrusted JavaScript code","text":"<p>The ability for PyMiniRacer to run untrusted JavaScript code was an original design goal for Sqreen in developing PyMiniRacer, and continues to be a design goal today.</p> <p>To that end, PyMiniRacer provides:</p> <ol> <li> <p>The innate sandboxing properties of V8. V8 is trusted by billions of folks to run     untrusted JavaScript every day, as a part of Chrome and other web browsers. It has     many features like the security sandbox and     undergoes close security scrutiny.</p> </li> <li> <p>The ability to create multiple <code>MiniRacer</code> instances which each have separate V8     isolates, to separate different blobs of untrusted code from each other.</p> </li> <li> <p>Optional timeouts and memory constraints on code being executed.</p> </li> </ol> <p>Caveats:</p> <ol> <li> <p>The continual security research is V8 under yields a corresponding     stream of vulnerability reports.</p> </li> <li> <p>... and while V8 as embedded in a web browser will typically receive (funded!)     updates to correct those vulnerabilities, PyMiniRacer is unlikely to see as     aggressive and consistent an update schedule.</p> </li> <li> <p>... and of course PyMiniRacer itself may have vulnerabilities.     This has happened before.</p> </li> <li> <p>... and even if PyMiniRacer is updated to accomodate a vulnerability fix in itself or     V8, it is incumbent upon Python applications which integrate it to actually     redeploy with the new PyMiniRacer version.</p> </li> </ol> <p>If running potentially adversarial JavaScript code in a high-security environment, it might be a better choice to run code using a purpose-built isolation environment such as containers on gVisor, than to rely on PyMiniRacer for isolation.</p>"},{"location":"architecture/#javascript-to-python-callbacks-may-breach-any-isolation-boundary","title":"JavaScript-to-Python callbacks may breach any isolation boundary","text":"<p>The <code>MiniRacer.wrap_py_function</code> method allows PyMiniRacer users to expose Python functions they write to JavaScript. This creates an extension framework which essentially breaches the isolation boundary provided by V8.</p> <p>This feature should only be used if the underlying JavaScript code is trusted, or if the author is certain the exposed Python function is safe for calls from untrusted code. (I.e., if you expose a Python function which allows reading arbitrary files from disk, this would obviously be bad if the JavaScript code which may call it is itself untrusted.)</p>"},{"location":"architecture/#brief-catalog-of-key-components","title":"Brief catalog of key components","text":""},{"location":"architecture/#docs","title":"<code>docs/</code>","text":"<p>This is the <code>mkdocs</code>  site for PyMiniRacer. To maximize compatibility with standard open-source repository layout, this directory is just a bunch of stubs which include files from the package root.</p>"},{"location":"architecture/#hatch_buildpy","title":"<code>hatch_build.py</code>","text":"<p>This is a Hatch build hook which builds Python wheels, by calling <code>helpers/v8_build.py</code>.</p>"},{"location":"architecture/#helpersv8_buildpy","title":"<code>helpers/v8_build.py</code>","text":"<p>This is the PyMiniRacer V8 build wrapper. Building V8 for many platforms (Windows, Mac, glibc Linux, musl Linux) and architectures (x86_64, aarch64) is hard, especially since V8 is primarily intended to be built by Google engineers on a somewhat different set of of platforms (i.e., those Chrome runs on), and typically via cross-compiled from relatively curated build hosts. So this file is complicated and full of <code>if</code> statements.</p>"},{"location":"architecture/#srcv8_py_frontend","title":"<code>src/v8_py_frontend/</code>","text":"<p>This is a small frontend for V8, written in C++. It manages initialization, context, marshals and unmarshals inputs and outputs through V8's type system, etc. The front-end exposes simple functions and types which are friendly to the Python <code>ctypes</code> system. These simple C++ functions in turn call the C++ V8 APIs.</p> <p>As noted below, <code>v8_py_frontend</code> is not a Python extension (it does not include <code>Python.h</code> or link <code>libpython</code>, and it does not touch Python types).</p>"},{"location":"architecture/#compiled-srcpy_mini_racerlibmini_racerso-srcpy_mini_racermini_racerdll-srcpy_mini_racerlibmini_racerdylib","title":"(Compiled) <code>src/py_mini_racer/libmini_racer.so</code>, <code>src/py_mini_racer/mini_racer.dll</code>, <code>src/py_mini_racer/libmini_racer.dylib</code>","text":"<p>These files (which one depends on the platform) contain the compiled V8 build, complete with the frontend from <code>src/v8_py_frontend</code>.</p>"},{"location":"architecture/#compiled-srcpy_mini_racericudtldat","title":"(Compiled) <code>src/py_mini_racer/icudtl.dat</code>","text":"<p>This is a build-time-generated internationalization artifact, used at runtime by V8 and thus shipped with PyMiniRacer.</p>"},{"location":"architecture/#compiled-srcpy_mini_racersnapshot_blobbin","title":"(Compiled) <code>src/py_mini_racer/snapshot_blob.bin</code>","text":"<p>This is a build-time-generated startup snapshot, used at runtime by V8 and thus shipped with PyMiniRacer. This is a snapshot of the JavaScript heap including JavaScript built-ins, which accelerates JS engine startup.</p>"},{"location":"architecture/#srcpy_mini_racer","title":"<code>src/py_mini_racer/</code>","text":"<p>This is the pure-Python implementation of PyMiniRacer. This loads the (Python-independent) PyMiniRacer dynamic-link library (<code>.dll</code> on windows, <code>.so</code> on Linux, <code>.dylib</code> on MacOS) and uses the Python <code>ctypes</code> system to call methods within it, to manage V8 context and actually evaluate JavaScript code.</p>"},{"location":"architecture/#githubworkflowsbuildyml","title":"<code>.github/workflows/build.yml</code>","text":"<p>This is the primary build script for PyMiniRacer, implemented as a GitHub Actions workflow.</p>"},{"location":"architecture/#design-decisions","title":"Design decisions","text":"<p>These are listed in a topological sort, from most-fundamental to most-derived decisions.</p> <p>In theory, answers to questions in the vein of \"Why is it done this way?\" belong in this section.</p>"},{"location":"architecture/#minimize-the-interface-with-v8","title":"Minimize the interface with V8","text":"<p>V8 is extremely complex and is under continual, heavy development. Such development can result in interface changes, which may in turn break PyMiniRacer.</p> <p>To mitigate the risk of breakage with new V8 builds, we seek to minimize the \"API surface area\" between PyMiniRacer and V8. This means we seek to limit \"advanced\" use of both:</p> <ol> <li>The V8 C++ API, and</li> <li>The V8 build system (GN) and build options.</li> </ol> <p>Our success at minimizing the interface with the V8 build system can be measured by:</p> <ol> <li>The number of times the text <code>v8::</code> appears in <code>src/v8_py_frontend</code>, and</li> <li>The length of <code>helpers/v8.build.py</code> (467 lines as of this writing!). Making V8 build     on multiple platforms takes a lot of trickery...</li> </ol>"},{"location":"architecture/#build-v8-from-source","title":"Build V8 from source","text":"<p>The V8 project does not produce stable binary distributions, i.e., static or dynamic libraries. (In Linux terms, this would probably look like dpkgs and rpms with names like <code>libv8</code> and <code>libv8-dev</code>.) Instead, any project (like NodeJS, Chromium, or... PyMiniRacer!) which wants to integrate V8 must first build it.</p>"},{"location":"architecture/#build-pypi-wheels","title":"Build PyPI wheels","text":"<p>Because V8 takes so long to build (about 2-3 hours at present on the free GitHub Actions runners, and &gt;12 hours when emulating <code>aarch64</code> on them), we want to build wheels for PyPI. We don't want folks to have to build V8 when they <code>pip install mini-racer</code>!</p> <p>We build wheels for many operating systems and architectures based on popular demand via GitHib issues. Currently the list is <code>{x86_64, aarch64} \u00d7 {Debian Linux, Alpine Linux, Mac, Windows}</code> (but skipping Windows <code>aarch64</code> for now since there is not yet either a GitHub Actions runner, or emulation layer for it).</p>"},{"location":"architecture/#use-the-free-github-actions-hosted-runners","title":"Use the free GitHub Actions hosted runners","text":"<p>PyMiniRacer is not a funded project, so we run on the free GitHub Actions hosted runners. These currently let us build for many key platforms (including via emulation).</p> <p>This also lets contributors easily run the same build automation by simply forking the PyMiniRacer repo and running the workflows (for free!) within their own forks.</p>"},{"location":"architecture/#dont-interface-with-the-cpython-api-dont-make-an-extension","title":"Don't interface with the CPython API (don't make an extension)","text":"<p>We'd rather avoid directly interfacing with the CPython API, for a couple reasons:</p> <ol> <li>API flux: Similar to the above note about V8, the CPython API is complex and     always in flux, although not as much as V8).</li> <li>Version proliferation: there are a ton of active Python versions (as of this     writing, PyMiniRacer supports 3.8, 3.9, 3.10, 3.11, and 3.12, and also there's     CPython and PyPy). PyMiniRacer already includes builds for 7 target architectures     (see above); if we factor in 5x Python versions and 2x Python interpreters, we will     wind up with 70 wheels, all on a free GitHub Actions runner!</li> </ol> <p>So, instead of an extension module (which includes <code>Python.h</code> and links against <code>libpython</code>), we build an ordinary Python-independent C++ library, and use <code>ctypes</code> to access it.</p> <p>Consequently, <code>libmini_racer.so</code> isn't specific to Python, and the code barely mentions Python. One could in theory use it from any other language which knows how to call C APIs, such as Java, Go, C#, ... or just C. No one does so as of this writing.</p>"},{"location":"architecture/#use-uraimorun-on-arch-action","title":"Use <code>uraimo/run-on-arch-action</code>","text":"<p>So, we need to build wheels for multiple architectures. For Windows and Mac (<code>x86_64</code> on Windows, and both <code>x86_64</code> and <code>aarch64</code> on Mac) we can can use GitHub hosted runners as-is. For Linux builds (Debian and Alpine, and <code>x86_64</code> and <code>aarch64</code>), we use the fantastic GitHub Action workflow step <code>uraimo/run-on-arch-action</code>, which lets us build a docker container on the fly and run it on QEMU.</p>"},{"location":"architecture/#dont-use-cibuildwheel","title":"Don't use <code>cibuildwheel</code>","text":"<p>Many modern Python projects which need to build wheels with native code use the <code>cibuildwheel</code> project to manange their builds. However, <code>cibuildwheel</code> isn't a perfect fit here. Because we are building Python-independent dynamic-link libraries instead of Python extension modules modules for the reasons noted above, we aren't linking with any particular Python ABI. Thus we need only <code>(operating systems \u00d7 architectures)</code> builds, whereas <code>cibuildwheel</code> generates <code>(operating systems \u00d7 architecture \u00d7 Python flavors \u00d7 Python versions)</code> wheels. That's a ton of wheels! Given that it takes hours to days to build PyMiniRacer for one target OS and architecture, doing redundant builds is undesirable.</p> <p>It might be possible to use <code>cibuildwheel</code> with PyMiniRacer by segmenting the build of the dynamic-link library (i.e., <code>libmini_racer.so</code>) from the actual wheel build. That is, we could have the following separate components:</p> <ol> <li>Create a separate Github Actions workflow to build the <code>libmini_racer.so</code> binary     (i.e., the hard part). Publish that as a release, using the GitHub release artifact     management system as a distribution mechanism.</li> <li>The wheel build step could then simply download a pre-built binary from the latest     GitHub release. We could use <code>cibuildwheel</code> to manage this step. This would     generate many redundant wheels (because the wheels we'd generate for, say, CPython     3.9 and 3.10 would be identical), but it wouldn't matter because it would be cheap     and automatic.</li> </ol> <p>This is similar to how the Ruby <code>mini_racer</code> and <code>libv8-node</code> projects, which inspired PyMiniRacer, work together today.</p> <p>To sum up, to use <code>cibuildwheel</code>, we would still need our own separate multi-architecture build workflow for V8, ahead of the <code>cibuildwheel</code> step. So <code>cibuildwheel</code> could potentially simplify the actual wheel distribution for us, but it wouldn't simplify the overall workflow management.</p>"},{"location":"architecture/#use-sccache-to-patch-around-build-timeouts","title":"Use <code>sccache</code> to patch around build timeouts","text":"<p>As of this writing, the Linux <code>aarch64</code> builds run on emulation becaues GitHub Actions has no free hosted <code>aarch64</code> runners for Linux. This makes them so slow, they struggle to complete at all. They take about 24 hours to run. The GitHub Actions job timeout is only 6 hours, so we have to restart the jobs multiple times. We rely on <code>sccache</code> to catch the build up to prior progress.</p> <p>It would in theory be less ugly to segment the build into small interlinked jobs of less than 6 hours each so they each succeed, but for now it's simpler to just manually restart the failed jobs, each time loading from the build cache and making progress, until they finally succeed. Hopefully at some point GitHub will provide native <code>aarch64</code> Linux runners, which will alleviate this problem.</p> <p>Hopefully, per this GitHub community discussion thread, we will get a free Linux <code>aarch64</code> runner in 2024 and can dispense with cross-architecture emulation.</p>"},{"location":"architecture/#build-v8-with-our-frontend-v8_py_frontend-as-a-snuck-in-component","title":"Build V8 with our frontend (<code>v8_py_frontend</code>) as a snuck-in component","text":"<p>We could just get a static library (i.e., <code>libv8.a</code>) from the V8 build, and link that into a dynamic-link library (i.e., <code>libmini_racer.so</code>) ourselves.</p> <p>However:</p> <ol> <li>We do have more C++ files to compile (the C++ code in <code>src/v8_py_frontend</code>)</li> <li>Because we're not making a true Python extension module (see above), we aren't using     Python's <code>setuptools</code> <code>Extension</code> infrastructure to perform a build.</li> </ol> <p>This leaves us needing some platform-independent C++ toolchain.</p> <p>V8 already has such a toolchain, based on Ninja and Generated Ninja files (GN). We already have to set it up to build V8 from source (see above for why!).</p> <p>Rather than bringing in yet another toolchain, we sneak <code>v8_py_frontend</code> into the V8 tree itself, as a \"custom dep\". We then instruct GN to build it as if it were an ordinary part of V8.</p> <p>The result is a dynamic-link library which contains an ordinary release build of V8, plus our Python <code>ctypes</code>-friendly frontend.</p>"},{"location":"architecture/#buggy-or-adversarial-javascript-shouldnt-be-able-to-crash-or-otherwise-disrupt-things","title":"Buggy or adversarial JavaScript shouldn't be able to crash or otherwise disrupt things","text":"<p>Per the security goals above, we want PyMiniRacer to be able to run untrusted JavaScript code safely. This means we can't trust JavaScript to \"behave\". Intentionally bad (i.e, adversarial) or unintentionally bad (i.e., buggy) JavaScript should not be able to:</p> <ol> <li>Crash PyMiniRacer,</li> <li>Read arbitrary memory, or</li> <li>Use infinite CPU or memory resources</li> </ol> <p>For the latter, the PyMiniRacer Python API exposes optional constraints on memory usage as well as timeouts. The former two rules are enforced by the design of the C++ side of PyMiniRacer, and of course V8 itself.</p>"},{"location":"architecture/#dont-trust-javascript-with-memory-management-of-c-objects","title":"Don't trust JavaScript with memory management of C++ objects","text":"<p>JavaScript is a garbage-collected language, and like many such languages it offers best-effort finalizer functionality, into which you can inject code which gets called when the runtime is disposing of an object.</p> <p>However, with V8-based JavaScript, actually relying on this functionality to trigger callbacks to C++ to clean things up is heartily discouraged. Exploratory attempts to make this with PyMiniRacer actually didn't work at all.</p> <p>Even if we could get V8 to call us back reliably to tear down objects (e.g., by exposing an explicit teardown function to JavaScript), it would be hard to create a design which does so safely. V8 (per our security goals) may be running adversarial JavaScript which might try and use a reference after we free it, exploiting a use-after-free bug.</p>"},{"location":"architecture/#any-raw-c-object-pointers-and-references-given-to-javascript-must-outlive-the-v8isolate","title":"Any raw C++ object pointers and references given to JavaScript must outlive the <code>v8::Isolate</code>","text":"<p>Due to the above rule, we can't rely on V8 to tell us when it's done with any references we give it, until the <code>v8::Isolate</code> is torn down. So clearly the only thing we can do is ensure any raw pointers or references we hand to V8 are valid until after the <code>v8::Isolate</code> is torn down.</p>"},{"location":"architecture/#use-javascript-integer-ids-to-track-any-allocated-objects-on-the-c-side","title":"Use JavaScript integer IDs to track any allocated objects on the C++ side","text":"<p>The above said, we still have cases where we want to tell JavaScript about objects which have shorter lifecycles than the <code>v8::Isolate</code> itself. E.g., a function callback from JavaScript to C++ (and thus to Python) might only be used as a single <code>Promise.then</code> callback. If a long-running program were to create tons of <code>Promise</code>s, we'd want to garbage collect the callbacks as we go, without waiting for the whole <code>v8::Isolate</code> to exit.</p> <p>We can treat that case by \"laundering\" our raw C++ pointers and references through C++ maps (i.e., <code>std::unordered_map&lt;uint64_t, std::shared_ptr&lt;T&gt;&gt;</code>), giving V8 JavaScript only IDs into the map. We can convert IDs back into C++ pointers when JavaScript calls us back, after checking that they're still valid. (And we use <code>std::shared_ptr</code> to avoid tear-down race conditions wherein a map entry is removed in one thread while we're still using an object in another.)</p> <p>In this manner, the C++ side can be authoritative about when objects are torn down. It can delete C++ objects and remove them from the map whenever it sees fit. If JavaScript tries to use the ID after that point, such usage can be easily spotted and safely ignored.</p>"},{"location":"architecture/#buggy-python-shouldnt-be-able-to-crash-c","title":"Buggy Python shouldn't be able to crash C++","text":"<p>Similar to, but with a lower priority than the above rule regarding bad JavaScript, bad Python should not be able to crash the Python interpretter through PyMiniRacer. This is a common design principle for Python; bad code should not result in segmentation faults, sending developers scrambling to C/C++ debugging of core files, etc. Extension modules should uphold this principle.</p> <p>This applies only to unintentionally bad (i.e., buggy) Python code. PyMiniRacer does not and cannot protect itself from intentionally bad (i.e., adversarial) Python code. A determined Python programmer can always crash Python with ease without any help from PyMiniRacer. Try it!: <code>import ctypes; ctypes.cast(0x1, ctypes.c_char_p).value</code></p>"},{"location":"architecture/#minimize-trust-of-python-in-automatic-memory-management-of-c-objects","title":"Minimize trust of Python in automatic memory management of C++ objects","text":"<p>Python is also a garbage-collected language, and like JavaScript, it offers best-effort finalizer functionality.</p> <p>Like in JavaScript code, relying on Python's finalizer functionality is heartily discouraged. We can, at best, use <code>__del__</code> as a shortcut signaling we can go ahead and free something to help reduce memory usage, but we shouldn't rely on it.</p> <p>Since, unlike JavaScript, we do trust Python code, we can create explicit Python APIs to manage object lifecycle. The Pythonic way to do that is with context managers.</p> <p>Thus, for example, the MiniRacer Python <code>_Context</code> object, which wraps exactly one C++ <code>MiniRacer::Context</code> object, provides both a <code>__del__</code> finalizer for easy cleanup which always works \"eventually\", and an explicit context manager interface for PyMiniRacer users who want strong guarantees about teardown.</p>"},{"location":"architecture/#minimize-trust-of-python-in-handing-cc-pointers","title":"Minimize trust of Python in handing C/C++ pointers","text":"<p>The <code>ctypes</code> module lets Python directly wrangle C/C++ pointers. This can be used to send, receive, and mutate data shared between Python and C.</p> <p>This is obviously somewhat dangerous. Array overruns are an obvious problem. Use-after-free is more insidious: imagine the C++ side of PyMiniRacer returns a pointer to an object to Python, Python stores that pointer, the C++ frees the object, and then Python tries to use the pointer. This will work sometimes and crash\u2014or worse, read incorrect data\u2014at other times.</p>"},{"location":"architecture/#use-python-integer-ids-to-track-any-allocated-objects-on-the-c-side","title":"Use Python integer IDs to track any allocated objects on the C++ side","text":"<p>Thus, combining all the above rules, we wind up with a similar rule for Python as we have for JavaScript. Wherever possible, we avoid interchanging raw pointers between C++ and Python. Instead, we interchange integer IDs. The C++ side of PyMiniRacer can convert integer IDs to raw pointers using a map, after validating that the IDs are still valid.</p>"},{"location":"architecture/#except-for-binaryvaluehandle-pointers","title":"... except for <code>BinaryValueHandle</code> pointers","text":"<p>We break the above rule for <code>BinaryValueHandle</code> pointers. PyMiniRacer uses <code>BinaryValueHandle</code> to exchange most data between Python and C++. Python directly reads the contents of <code>BinaryValueHandle</code> pointers, to read primitive values (e.g., booleans, integers, and strings).</p> <p>We do this for theoretical performance reasons which have not yet been validated. To be consistent with the rest of PyMiniRacer's design, we could create an API like:</p> <ol> <li>C++ generates a numeric <code>value_id</code> and stores a BinaryValue in a     <code>std::unordered_map&lt;uint64_t, std::shared_ptr&lt;BinaryValue&gt;&gt;</code>.</li> <li>C++ gives Python that <code>value_id</code> to Python.</li> <li>To get any data Python has to call APIs like <code>mr_value_type(context_id, value_id)</code>,     <code>mr_value_as_bool(context_id, value_id)</code>,     <code>mr_value_as_string_len(context_id, value_id)</code>,     <code>mr_value_as_string(context_id, value_id, buf, buflen)</code>, ...</li> <li>Eventually Python calls <code>mr_value_free(context_id, value_id)</code> which wipes out the map     entry, thus freeing the <code>BinaryValue</code>.</li> </ol> <p>Note: We don't do this. The above is not how PyMiniRacer actually handles values.</p> <p>This is surely slower than direct pointer access, but no performance analysis has been done to see if it matters. It might be interesting to try the above and benchmark it. It would be nice to switch to that model if it's sufficiently performant.</p> <p>For now at least, we instead use raw pointers for this case.</p> <p>We still don't fully trust Python with the lifecyce of <code>BinaryValueHandle</code> pointers; when Python passes these pointers back to C++, we still check validity by looking up the pointer as a key into a map (which then lets the C++ side of PyMiniRacer find the rest of the <code>BinaryValue</code> object). The C++ <code>MiniRacer::BinaryValueFactory</code> can authoritatively destruct any dangling <code>BinaryValue</code> objects when it exits.</p> <p>This last especially helps with an odd scenario introduced by Python <code>__del__</code>: the order in which Python calls <code>__del__</code> on a collection of objects is neither guaranteed nor very predictable. When a Python program drops references to a Python <code>MiniRacer</code> object, it's common for Python to call <code>_Context.__del__</code> before it calls <code>ValHandle.__del__</code>, thus destroying the container for the value before it destroys the value itself. The C++ side of PyMiniRacer can easily detect this scenario: First, when destroying the <code>MiniRacer::Context</code>, it sees straggling <code>BinaryValue</code>s and destroys them. Then, when Python asks C++ to destroy the straggling <code>BinaryValueHandle</code>s, the C++ <code>mr_free_value</code> API sees the <code>MiniRacer::Context</code> is already gone, and ignores the redundant request.</p> <p>The above scenario does imply a possibility for dangling pointer access: if Python calls <code>_Context.__del__</code> then tries to read the memory addressed by the raw <code>BinaryValueHandle</code> pointers, it will be committing a use-after-free error. We mitigate this problem by hiding <code>BinaryValueHandle</code> within PyMiniRacer's Python code, and by giving <code>ValHandle</code> (our Python wrapper of <code>BinaryValueHandle</code>) a reference to the <code>_Context</code>, preventing the context from being finalized until the <code>ValHandle</code> is also in Python's garbage list and on its way out.</p>"},{"location":"architecture/#only-touch-most-of-the-v8isolate-from-within-the-message-loop","title":"Only touch (most of) the <code>v8::Isolate</code> from within the message loop","text":"<p>While a <code>v8::Isolate</code> is generally a thread-aware and multi-threaded object, most of its methods are not thread-safe. The same goes for most <code>v8</code> objects. It is, generally, only safe to touch things belonging to a <code>v8::Isolate</code> if you hold the <code>v8::Locker</code> lock. (To make matters more interesting, documentation about what things might be safe to do without the lock is pretty scarce. You find out when your unsafe code crashes. Which, you know, might not happen until years after you wrote the unsafe code. C++ is fun!)</p> <p>The \"don't touch the <code>v8::Isolate</code> without holding the <code>v8::Locker</code>\" rule is made particularly hard to follow since we also need to run a message loop thread to service background work in v8. That message loop, of course, itself needs the <code>v8::Locker</code>. Unfortunately, the message loop can wait indefinitely for new work, and yet doesn't give up the lock while doing that waiting.</p> <p>This poses a conundrum: the message loop hogs the isolate lock potentially indefinitely, and yet other threads (i.e., Python threads) need that lock so they can poke at <code>v8::Isolate</code>-owned objects too.</p> <p>We resolve the conundrum by leveraging part of the <code>v8::Isolate</code> itself, using a trick similar to what NodeJS does: everything that needs to touch a <code>v8::Isolate</code> should simply run from the <code>v8::Isolate</code>'s own message loop. If you want to run JS code, manipulate an object, or even delete a V8 object, you must submit a task to the message loop. Then nothing but the message loop itself should need to hold the <code>v8::Locker</code> lock, because only the message loop ever touches the <code>v8::Isolate</code>.</p> <p>To make this somewhat easier we have created <code>MiniRacer::IsolateManager</code>, which provides an easy API to submit tasks, whose callbacks accept as their first-and-only argument a <code>v8::Isolate*</code>. Such tasks can freely work on the isolate until they exit. (Obviously, saving a copy of the pointer and using it later would defeat the point; don't do that.)</p> <p>One odd tidbit of PyMiniRacer is that even object destruction has to use the above pattern. For example, it is (probably) not safe to free a <code>v8::Persistent</code> without holding the isolate lock, so when a non-message-loop thread needs to destroy a wrapped V8 value, we enqueue a pretty trivial task for the message loop: <code>isolate_manager-&gt;Run([persistent]() { delete persistent; })</code>.</p> <p>See here for some discussion of this design on the v8-users mailing list.</p>"},{"location":"architecture/#if-any-c-code-creates-an-isolate-task-its-responsible-for-awaiting-its-completion-before-teardown","title":"If any C++ code creates an Isolate task, it's responsible for awaiting its completion before teardown","text":"<p>The pattern, described above\u2014of enqueuing all kinds of tasks for the v8 message pump, including object destruction work\u2014creates an interesting memory management problem for PyMiniRacer. Such tasks typically create a reference cycle: the creator of the task (like, say, the <code>MiniRacer::Context::MakeJSCallback</code>) bundles into the task references to various other objects including, often, <code>this</code>. Those objects often themselves contain references to the <code>MiniRacer::IsolateManager</code>, which transitively contains a reference to the <code>v8::Isolate</code> and its message queue. Since the message queue contains a reference to the task, we've just created a reference cycle!</p> <p>To avoid either use-after-free or memory leak bugs upon teardown of a <code>MiniRacer::Context</code>, we must enforce the following rule:</p> <p>If you call <code>MiniRacer::IsolateManager::Run(xyz)</code>, you are reponsible for ensuring that task is done before any objects you bound into the function closure xyz (including and especially <code>this</code>) are destroyed.</p> <p>The most common way we ensure this is waiting on the <code>std::future&lt;void&gt;</code> returned by <code>MiniRacer::IsolateManager::Run(xyz)</code>. When that future settles, the task is done, and it's safe to continue tearing down any references the task may hold.</p>"},{"location":"authors/","title":"Credits","text":""},{"location":"authors/#authors","title":"Authors","text":"<ul> <li>Jean-Baptiste AVIAT jb@sqreen.com</li> <li>Boris FELD boris@sqreen.com</li> <li>Selim MENOUAR selim@sqreen.com</li> <li>Nicolas VIVET nicolas@sqreen.com</li> </ul>"},{"location":"authors/#contributors","title":"Contributors","text":"<ul> <li>messense https://github.com/messense</li> <li>Ben Creech https://github.com/bpcreech</li> </ul> <p>Why not add your name to the list?</p>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":"<p>You can contribute in many ways:</p>"},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/bpcreech/PyMiniRacer/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with \"bug\" is open to whoever wants to implement it.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with \"feature\" is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p>Python Mini Racer could always use more documentation, whether as part of the official Python Mini Racer docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/bpcreech/PyMiniRacer/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions are welcome     :)</li> </ul>"},{"location":"contributing/#get-started","title":"Get Started!","text":"<p>Ready to contribute? Here's how to set up <code>PyMiniRacer</code> for local development.</p> <p>Warning</p> <p>Building this package from source takes several GB of disk space and takes 1-2 hours.</p> <ol> <li> <p>Do a quick scan through the architecture guide before diving in.</p> </li> <li> <p>Fork the <code>PyMiniRacer</code> repo on GitHub.</p> </li> <li> <p>If you plan to change C++ code you should probably install at least <code>clang-format</code>     and <code>clang-tidy</code> from the latest stable LLVM. While     the <code>PyMiniRacer</code> build uses its own compiler (!) on most systems, our pre-commit     rules rely on the system <code>clang-format</code> and <code>clang-tidy</code>. If your versions of those     utilities do not match the ones <code>PyMiniRacer</code> uses on GitHub Actions, you may see     spurious pre-commit errors.</p> <p>If you're on a Debian-related Linux distribution using the LLVM project's standard apt packages, note that you will likely have to override <code>/usr/bin/clang-format</code> and <code>/usr/bin/clang-tidy</code> to point to the latest version, i.e., <code>/usr/bin/clang-format-18</code> and <code>/usr/bin/clang-tidy-18</code>, respectively.</p> <p>You can always silence local pre-commit errors with the <code>-n</code> argument to <code>git commit</code>. We check <code>pre-commit</code>s on every pull request using GitHub Actions, so you can check for errors there instead.</p> </li> <li> <p>Run some of the following:</p> <pre><code>    # Set up a virtualenv:\n    $ python -m venv ~/my_venv\n    $ . ~/my_venv/bin/activate\n    $ pip install pre-commit hatch hatch-mkdocs\n\n    # Set up a local clone of your fork:\n    $ git clone git@github.com:your_name_here/PyMiniRacer.git\n    $ cd PyMiniRacer/\n    $ pre-commit install  # install our pre-commit hooks\n\n    # Build and test stuff:\n    $ hatch run docs:serve  # build the docs you're reading now!\n    $ hatch build  # this may take 1-2 hours!\n    $ hatch run test:run\n</code></pre> <p>You can also play with your build in the Python REPL, as follows:</p> <pre><code>    $ hatch shell\n    $ python\n    &gt;&gt;&gt; from py_mini_racer import MiniRacer\n    &gt;&gt;&gt; mr = MiniRacer()\n    &gt;&gt;&gt; mr.eval('6*7')\n    42\n    &gt;&gt;&gt; exit()\n    $ exit\n</code></pre> <p>As a shortcut for iterative development, you can skip the <code>hatch build</code> and matrix tests, and do:</p> <pre><code>    $ python helpers/v8_build.py [--skip-fetch]  # will install a DLL into src/py_mini_racer\n    $ PYTHONPATH=src pytest  # run the tests\n    $ PYTHONPATH=src python  # play with the build in the REPL\n    &gt;&gt;&gt; from py_mini_racer import MiniRacer\n    &gt;&gt;&gt; ...\n</code></pre> </li> <li> <p>Create a branch for local development::</p> <pre><code>    $ git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> </li> <li> <p>When you're done making changes, check that your changes pass the linter and the     tests, including testing other Python versions:</p> <pre><code>   $ pre-commit run  # run formatters and linters\n   $ hatch run docs:serve  # look at the docs if you changed them!\n   $ hatch build  # this may take 1-2 hours!\n   $ hatch run test:run\n   $ hatch run test:run-coverage  # with coverage!\n</code></pre> </li> <li> <p>Commit your changes and push your branch to GitHub::</p> <pre><code>   $ git add .\n   $ git commit -m \"Your detailed description of your changes.\"\n   $ git push origin name-of-your-bugfix-or-feature\n</code></pre> </li> <li> <p>(Optional) Run the GitHub Actions build workflow on your fork to ensure that all     architectures work.</p> </li> <li> <p>Submit a pull request through the GitHub website.</p> </li> </ol>"},{"location":"contributing/#tests","title":"Tests","text":"<p>If you want to run the tests, you need to build the package first:</p> <pre><code>    $ hatch build\n</code></pre> <p>Then run:</p> <pre><code>    $ hatch run test\n</code></pre> <p>Or for the full test matrix:</p> <pre><code>    $ hatch run test:run\n    $ hatch run test:run-coverage  # with coverage!\n</code></pre>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li>The pull request should include tests.</li> <li>If the pull request adds functionality, the docs should be updated. Put your new     functionality into a function with a docstring, and add the feature to the list in     README.md.</li> <li>The pull request should work for the entire test matrix of Python versions     (<code>hatch run tests:run</code>).</li> </ol>"},{"location":"contributing/#releasing-pyminiracer","title":"Releasing <code>PyMiniRacer</code>","text":"<p>Releases for <code>PyMiniRacer</code> should be done by GitHub Actions on the official project repository.</p>"},{"location":"contributing/#ordinary-releases","title":"Ordinary releases","text":"<p>To make an ordinary release from <code>main</code>:</p> <ol> <li> <p>Merge all changes into <code>main</code> on the official repository.</p> </li> <li> <p>Pick the next revision number:</p> <pre><code>$ git fetch\n$ git ls-remote origin | grep refs/heads/release\n# observe the next available release version\n</code></pre> </li> <li> <p>Create a <code>feature/...</code> branch, and:</p> <ol> <li> <p>Update <code>HISTORY.md</code> with a summary of changes since the last release.</p> </li> <li> <p>Update <code>src/py_mini_racer/__about__.py</code> with the new revision number.</p> </li> <li> <p>Create and merge a pull request for this branch into <code>main</code>.</p> </li> </ol> </li> <li> <p>Create a <code>release/...</code> branch:</p> <pre><code>$ git checkout main\n$ git pull\nNEXT_RELEASE=the next tag, starting with the letter v. E.g., \"v0.12.1\".\n$ git checkout -b \"release/${NEXT_RELEASE}\"\n$ git push --set-upstream origin \"release/${NEXT_RELEASE}\"\n</code></pre> </li> <li> <p>Observe the build process on GitHub Actions. It should build and push docs and upload     wheels to PyPI automatically.</p> <p>Warning</p> <p>As of this writing, the <code>aarch64</code> Linux builds are slow because they're running on emulation. They time out on the first try (and second and third and...) after 6 hours. If you \"restart failed jobs\", they will quickly catch up to where where they left off due to <code>sccache</code>. The jobs should eventually complete within the time limit. You can observe their slow progress using the Ninja build status (e.g., <code>[1645/2312] CXX obj/v8_foo_bar.o</code>).</p> </li> </ol>"},{"location":"contributing/#hotfix-releases","title":"Hotfix releases","text":"<p>To hotfix a prior release:</p> <ol> <li> <p>Prepare the fix as a <code>feature</code> branch as normal, and merge it into <code>main</code>.</p> </li> <li> <p>Pick the next revision number. This will typically be a patch-version update on the     current release name.</p> </li> <li> <p>Create a new release branch for the hotfix:</p> <pre><code>BASE_RELEASE=the release you are hotfixing, starting with the letter v. E.g., \"v0.12.0\".\nNEXT_RELEASE=the next tag, starting with the letter v. E.g., \"v0.12.1\".\n$ git checkout \"release/${BASE_RELEASE}\"\n$ git pull\n$ git checkout -b \"release/${NEXT_RELEASE}\"\n</code></pre> </li> <li> <p>Hotfix the commit(s) created in step #1 onto the new release branch.</p> </li> <li> <p>Create a version update commit:</p> <ol> <li> <p>Update <code>HISTORY.md</code> with a summary of changes since the last release.</p> </li> <li> <p>Update <code>src/py_mini_racer/__about__.py</code> with the new revision number.</p> </li> </ol> </li> <li> <p>Commit and push the new release branch to GitHub.</p> </li> <li> <p>Merge this branch into <code>main</code>. All content on release branches should be included in     <code>main</code>.</p> </li> <li> <p>Observe the build process on GitHub Actions. It should build and push docs and upload     wheels to PyPI automatically.</p> </li> </ol>"},{"location":"history/","title":"History","text":""},{"location":"history/#0124-2024-06-16","title":"0.12.4 (2024-06-16)","text":"<ul> <li>Upgrade to V8 12.6 from 12.4.</li> </ul>"},{"location":"history/#0123-2024-05-25","title":"0.12.3 (2024-05-25)","text":"<ul> <li>Fix potential hang if JavaScript calls a function produced by <code>wrap_py_function</code> while     we're tearing it down.</li> </ul>"},{"location":"history/#0122-2024-05-20","title":"0.12.2 (2024-05-20)","text":"<ul> <li> <p>Add optional context manager and <code>.close()</code> semantics to Python <code>MiniRacer</code> class.</p> </li> <li> <p>Fixed a potential hang on MiniRacer teardown if MiniRacer is executing a microtask     which loops infinitely.</p> </li> <li> <p>Switch C++ side of MiniRacer to a more straightforward object lifecycle management     model.</p> </li> </ul>"},{"location":"history/#0121-2024-05-18","title":"0.12.1 (2024-05-18)","text":"<ul> <li>Update to V8 12.4. This includes fixes for CVE-2024-3159, CVE-2024-3156, and     CVE-2024-2625. These vulnerabilities in V8 would impact PyMiniRacer users who are     running untrusted and adversarial JavaScript code.</li> </ul>"},{"location":"history/#0120-2024-04-29","title":"0.12.0 (2024-04-29)","text":"<ul> <li> <p>Added support for installing callbacks from JS back into Python, using     MiniRacer.wrap_py_function.</p> </li> <li> <p>Refactored the Python implementation into many internal files. This should mostly not     present a breaking change, except for code which reaches into internal     (<code>_</code>-prefixed) variables.</p> </li> </ul>"},{"location":"history/#0111-2024-04-08","title":"0.11.1 (2024-04-08)","text":"<ul> <li> <p>Fixed Python crash on long-running microtasks, introduced in v0.8.1 (before which     long-running microtasks would probably not run at all).</p> </li> <li> <p>Fixed memory leak on the exception object reported when an <code>eval</code> times out.</p> </li> <li> <p>Hardened the memory management of JS value interchange, context tracking, and     asynchronous task tracking between C++ and Python.</p> </li> <li> <p>Added exhaustive typing (now with a MyPy pre-commit to verify!)</p> </li> <li> <p>Added a test asserting that the v8 sandbox is enabled     on all platforms we build wheels for.</p> </li> </ul>"},{"location":"history/#0110-2024-04-03","title":"0.11.0 (2024-04-03)","text":"<ul> <li> <p>Added a <code>MutableMapping</code> (<code>dict</code>-like) interface for all derivatives of JS Objects,     and a <code>MutableSequence</code> (<code>list</code>-like) interface for JS Arrays. You can now use     Pythonic idioms to read and write Object properties and Array elements in Python,     including recursively (i.e., you can read Objects embedded in other objects, and     embed your own).</p> </li> <li> <p>Added ability to directly call <code>JSFunction</code> objects from Python. E.g.,     <code>mr.eval(\"a =&gt; a*a\")(4)</code> parses the given number-squaring code into a function,     returns a handle to that function to Python, calls it with the number <code>4</code>, and     recieves the result of <code>16</code>.</p> </li> <li> <p>Added a <code>JSUndefined</code> Python object to model JavaScript <code>undefined</code>. This is needed to     properly implement the above interface for reading Object and Array elements.     Unfortunately, this may present a breaking change for users who assume JavaScript     <code>undefined</code> is modeled as Python <code>None</code>.</p> </li> <li> <p>Removed an old optimization for <code>eval</code> on simple no-argument function calls (i.e.,     <code>myfunc()</code>). The optimization only delivered about a 17% speedup on no-op calls (and     helped relatively less on calls which actually did work), and for the purpose of     optimizing repeated calls to the same function, it's now redundant with extracting     and calling the function from Python, e.g., <code>mr.eval(\"myfunc\")()</code>.</p> </li> <li> <p>Hardening (meaning \"fixing potential but not-yet-seen bugs\") related to freeing     <code>BinaryValue</code> instances (which convey data from C++ to Python).</p> </li> <li> <p>More hardening related to race conditions on teardown of the <code>MiniRacer</code> object in the     unlikely condition that <code>eval</code> operations are still executing on the C++ side, and     abandoned on the Python side, when Python attempts to garbage collect the     <code>MiniRacer</code> object.</p> </li> </ul>"},{"location":"history/#0100-2024-03-31","title":"0.10.0 (2024-03-31)","text":"<ul> <li> <p>Updated to V8 12.3 from V8 12.2 now that Chromium stable is on 12.3.</p> </li> <li> <p>Added Python-side support for JS Promises. You can now return a JS Promise from code     executed by <code>MiniRacer.eval</code>, and PyMiniRacer will convert it to a Python object     which has a blocking <code>promise.get()</code> method, and also supports <code>await promise</code> in     <code>async</code> Python functions.</p> </li> <li> <p>Added a <code>setTimeout</code> and <code>clearTimeout</code>. These common functions live in the Web API     standard, not the ECMAScript standard, and thus don't come with V8, but they're so     ubiquitious we now ship an implemention with <code>PyMiniRacer</code>.</p> </li> </ul>"},{"location":"history/#090-2024-03-30","title":"0.9.0 (2024-03-30)","text":"<ul> <li> <p>Revamped JS execution model to be out-of-thread. Python/C++ interaction now happens     via callbacks.</p> </li> <li> <p>Consequently, Control+C (<code>KeyboardInterrupt</code>) now interrupts JS execution.</p> </li> <li> <p>Hardened C++-side thread safety model, resolving potential race conditions introduced     in v0.8.1 (but not actually reported as happening anywhere).</p> </li> <li> <p>Further improved JS exception reporting; exception reports now show the offending code     where possible.</p> </li> <li> <p>Introduced <code>timeout_sec</code> parameter to <code>eval</code>, <code>call</code>, and <code>execute</code> to replace the     <code>timeout</code>, which unfortunately uses milliseconds (unlike the Python standard     library). In the future we may emit deprecation warnings for use of <code>timeout</code>.</p> </li> </ul>"},{"location":"history/#081-2024-03-23","title":"0.8.1 (2024-03-23)","text":"<ul> <li>A series of C++ changes which should not impact the behavior of PyMiniRacer:</li> <li>Refactoring how we use V8 by inverting the control flow. Before we had function     evaluations which ran and drained the message loop. Now we have an always-running     message loop into which we inject function evaluations. This seems to be the     preferred way to use V8. This is not expected to cause any behavior changes (but, in     tests, makes     microtask competion     more consistent).</li> <li>Refactoring the C++ implementation into multiple components to make startup and     teardown logic more robust.</li> <li>Added tests for the existing fast-function-call path.</li> <li>Also, simplified Python conversion of C++ evaluation results.</li> </ul>"},{"location":"history/#080-2024-03-18","title":"0.8.0 (2024-03-18)","text":"<ul> <li>General overhaul of C++ implementation to better adhere to modern best practice. This     should have no visible impact except for the following notes...</li> <li>Exposed the hard memory limit as a context-specific (as opposed to <code>eval</code>-specific)     limit, since that's how it worked all along anyway. The <code>max_memory</code> <code>eval</code> argument     still works for backwards compatibility purposes.</li> <li>Correct message type of some exceptions to <code>str</code> instead of <code>bytes</code> (they should all     be <code>str</code> now).</li> <li>Added better messages for JS parse errors.</li> <li>Added backtraces for more JS errors.</li> <li>Added some really basic Python typing.</li> </ul>"},{"location":"history/#070-2024-03-06","title":"0.7.0 (2024-03-06)","text":"<ul> <li>Update V8 to 12.2</li> <li>Drop Python 2 support</li> <li>Fix small Python 3.12 issue and add testing for Python 3.9-3.12</li> <li>Add aarch64 support for Mac and Linux</li> <li>Revamp DLL loading to be compliant with Python 3.9-style resource loading. This may     present a small breaking change for advanced usage; the <code>EXTENSION_PATH</code> and     <code>EXTENSION_NAME</code> module variables, and <code>MiniRacer.v8_flags</code> and <code>MiniRacer.ext</code>     class variable have all been removed.</li> <li>Add support for the ECMAScript internalization API and     thus the ECMA <code>Intl</code> API</li> <li>Use fast startup snapshots</li> <li>Switch from setuptools to Hatch</li> <li>Switch from tox to Hatch</li> <li>Switch from flake8 and isort to Hatch's wrapper of Ruff</li> <li>Switch from Sphinx to mkdocs (and hatch-mkdocs)</li> <li>Switch from unittest to pytest</li> <li>Add architecture.md and lots of code comments</li> </ul>"},{"location":"history/#060-2020-04-20","title":"0.6.0 (2020-04-20)","text":"<ul> <li>Update V8 to 8.9</li> <li>Optimize function calls without arguments</li> <li>Switch V8 to single threaded mode to avoid crashes after fork</li> <li>Switch to strict mode by default</li> <li>Revamp documentation</li> </ul>"},{"location":"history/#050-2020-02-25","title":"0.5.0 (2020-02-25)","text":"<ul> <li>Update V8 to 8.8</li> </ul>"},{"location":"history/#040-2020-09-22","title":"0.4.0 (2020-09-22)","text":"<ul> <li>Universal wheels for Linux, Mac and Windows</li> <li>Fallback to source package for Alpine Linux</li> </ul>"},{"location":"history/#030-2020-06-29","title":"0.3.0 (2020-06-29)","text":"<ul> <li>Introduce a strict mode</li> <li>Fix array conversion when size changes dynamically (CVE-2020-25489)</li> </ul>"},{"location":"history/#020-2020-03-11","title":"0.2.0 (2020-03-11)","text":"<ul> <li>Support for Alpine Linux</li> <li>Avoid pip private modules in setup.py</li> </ul>"},{"location":"history/#020b1-2020-01-09","title":"0.2.0b1 (2020-01-09)","text":"<ul> <li>Support for Windows 64 bits</li> <li>Support for Python 3.8</li> <li>Upgrade V8 to 7.8</li> <li>Support soft memory limits</li> </ul>"},{"location":"history/#0118-2019-01-04","title":"0.1.18 (2019-01-04)","text":"<ul> <li>Support memory and time limits</li> </ul>"},{"location":"history/#0117-2018-19-12","title":"0.1.17 (2018-19-12)","text":"<ul> <li>Upgrade libv8</li> <li>Fix a memory leak</li> </ul>"},{"location":"history/#0116-2018-07-11","title":"0.1.16 (2018-07-11)","text":"<ul> <li>Add wheel for Python without PyMalloc</li> </ul>"},{"location":"history/#0115-2018-06-18","title":"0.1.15 (2018-06-18)","text":"<ul> <li>Add wheel for Python 3.7</li> </ul>"},{"location":"history/#0114-2018-05-25","title":"0.1.14 (2018-05-25)","text":"<ul> <li>Add support for pip 10</li> <li>Update package metadata</li> </ul>"},{"location":"history/#0113-2018-03-15","title":"0.1.13 (2018-03-15)","text":"<ul> <li>Add heap_stats function</li> <li>Fix issue with returned strings containing null bytes</li> </ul>"},{"location":"history/#0112-2018-17-04","title":"0.1.12 (2018-17-04)","text":"<ul> <li>Remove dependency to enum</li> </ul>"},{"location":"history/#0111-2017-07-11","title":"0.1.11 (2017-07-11)","text":"<ul> <li>Add compatibility for centos6</li> </ul>"},{"location":"history/#0110-2017-03-31","title":"0.1.10 (2017-03-31)","text":"<ul> <li>Add the possibility to pass a custom JSON encoder in call.</li> </ul>"},{"location":"history/#019-2017-03-24","title":"0.1.9 (2017-03-24)","text":"<ul> <li>Fix the compilation for Ubuntu 12.04 and glibc \\&lt; 2.17.</li> </ul>"},{"location":"history/#018-2017-03-02","title":"0.1.8 (2017-03-02)","text":"<ul> <li>Update targets build for better compatibility with old Mac OS X and linux platforms.</li> </ul>"},{"location":"history/#017-2016-10-04","title":"0.1.7 (2016-10-04)","text":"<ul> <li>Improve general performances of the JS execution.</li> <li>Add the possibility to build a different version of V8 (for example with debug     symbols).</li> <li>Fix a conflict that could happens between statically linked libraries and dynamic     ones.</li> </ul>"},{"location":"history/#016-2016-08-12","title":"0.1.6 (2016-08-12)","text":"<ul> <li>Add error message when py_mini_racer sdist fails to build asking to update pip in     order to download the pre-compiled wheel instead of the source distribution.</li> </ul>"},{"location":"history/#015-2016-08-04","title":"0.1.5 (2016-08-04)","text":"<ul> <li>Build py_mini_racer against a static Python. When built against a shared library     python, it doesn't work with a static Python.</li> </ul>"},{"location":"history/#014-2016-08-04","title":"0.1.4 (2016-08-04)","text":"<ul> <li>Ensure JSEvalException message is converted to unicode</li> </ul>"},{"location":"history/#013-2016-08-04","title":"0.1.3 (2016-08-04)","text":"<ul> <li>Fix extension loading for python3</li> <li>Add a make target for building distributions (sdist + wheels)</li> <li>Fix eval conversion for python 3</li> </ul>"},{"location":"history/#012-2016-08-03","title":"0.1.2 (2016-08-03)","text":"<ul> <li>Fix date support</li> <li>Fix Dockerfile for generating python3 wheels</li> </ul>"},{"location":"history/#011-2016-08-02","title":"0.1.1 (2016-08-02)","text":"<ul> <li>Fix sdist distribution.</li> </ul>"},{"location":"history/#010-2016-08-01","title":"0.1.0 (2016-08-01)","text":"<ul> <li>First release on PyPI.</li> </ul>"}]}